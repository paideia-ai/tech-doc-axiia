yih(00:00:00): 我们接着之前那个说法说，就是说我们的 pipeline 分两部分，一部分是 language model 生成的部分，截止到它生成出一个阶段是这样的。然后就是阶层后期的我们还有一些 post 的 process，有一些后处理。然后我们要解决的问题分别是。就是在前部分，我们好像还是要得用 chatbot 解决问题，就是在 language model 生成部分，我们需要去，我们需要在我再确认一下我们现在这个 language model 生成部分，我们对这个整个的生成 flow 的定制性，主要就通过这些变量的互相引用来实现？

anna(00:00:54): 定制性。

yih(00:00:55): 就比如说他先走哪个 prompt 再走哪个 prompt？

anna(00:00:59): 东西已经。

anna(00:01:03): 它是一整条完整的一个 flow，然后它不是说你就可以赌这样。

yih(00:01:10): 你可以中间跳过某一步，如果你不去进入那个。

anna(00:01:14): 他现在相当于是完整的。

yih(00:01:18): 比如说你 prompt 中没有变量，它还会走那步，就比如说。

anna(00:01:23): 你只能从头开始，从头到尾。

yih(00:01:27): 不能只跑一步。

anna(00:01:28): 对。你你说现在就是我们正式的报告产出的。

simon(00:01:38): 有一个 playground 和正式报告。

anna(00:01:40): 对这报告。

simon(00:01:42): 分别是？

anna(00:01:44): 从头到尾。

simon(00:01:45): 对。

anna(00:01:46): 或者是完整它不用的时候我只跑其中一个。

anna(00:01:51): 不光。

simon(00:01:53): 可以 progressive，你可以比如说12345，你可以先跑到第一步再跑第二跑到第三步，那第三步是来跑第一步跑完的。

yih(00:02:03): 有没有一种可能性，比如说我想跑第三步，但是我没有跑第一步，第二步，但是我提供一个 customer 的第一步跟第二步的 output。

yih(00:02:16): OK 好 playground 跟现实的中间有任何差别吗？

anna(00:02:27): 所以你如果说我在是不是很适合？

yih(00:02:31): 明白我只说他们在，比如说同样他们没有什么会导致他们说出很不一样的地方。那就有这个 playground，那这个 playground 本身。他是就打包的 binary？

yih(00:02:50): OK 好的。用这个 playground 来跑分的话，没有什么问题。

simon(00:02:57): 对。

yih(00:02:58): 这里可能更多是定义 buffer 的内容就是每部的 inputoutput。

simon(00:03:07): 或者如果我们要在如果我们要把比如说能力维度变少的话，在现在上要做很大改进。

yih(00:03:18): 现在七个我想改上。

simon(00:03:20): 改成五个我们中间决定，我这就假设就这种情况。

anna(00:03:32): 原因有一个变少，一个是代码维度，还有一个是 prompt 维度都需要。

yih(00:03:40): 放维度我们可以改维度看代码维度要怎么动。OK 我想前期的分发和部分还每一步都可以单独跑，然后每一步可以决定它应答复是什么，这个问题不大。可能需要一些简单的小的，如果搭配的话，可能一些额外代码，就比如说就是你检查 AI 的输出跟我们期待的输出是否足够相似，需要这么一些简单代码去做这些东西，其他的部分应该都是考试。

yih(00:04:38): 然后具体的分叉和内容的设置。

yih(00:04:58): 我先看一下我之前我记得七枪。

simon(00:05:01): But。

yih(00:05:01): 高分结果扣 it with 高分过程。

yih(00:05:20): 不应该出现没有过程的高分过程。没有很特殊，这样，我觉得我们这样我们就先练习我们的这种要求就 spec 就关于单窗还是 spec，然后我们把它再变成 testcase。

simon(00:05:38): 我现在 playground 它就是做完之后它会生成一个 jason，我们要 score 的话就相当于从 jason 里面再把 score 读出来这样子。

yih(00:06:03): 跟创这个事就是我们先一起列一些。要求，然后可能有一部分要求不可能也不太好直接列。就比如说我们希望对过程打分的 robert follow 的程度是比较好的，就我们可能需要做一点简单的人工审核，就比如说比如 verification 所谓分高的人，他们就究竟在干什么。就比如说我们之前，比如说你之前做的那个 pattern 就比较清楚，就是比如说他在 think trap 的题目前会跟 AI 聊一会儿，什么是 think trap 就类似于这样的。就算是得分点，对于维度上来说，但是我就可能我们需要一些这样的。得分点进入我们的 benchmark 里，我感觉。

simon(00:07:06): 我们就是我们跑很多分数据，最后数据它会有最后数据的分数，我们需要在。就是在最后跑出来数据之前，原本数据里面会有一些 proxy，这些 proxy 有的是比较简单，容易检测的。它就是恰当情况，有些是更难以检测的，有些行为发成这两层的 proxy 进行一些 check 和对应。

yih(00:07:41): 我觉得工作流可能这样，就比如我们先看所有我举例的 verification 维度分数高的人。

yih(00:07:49): 我们就先把我的分数就算 left model 它打分有问题，它打分高也总是有点原因的？

yih(00:07:55): 那我们可以先从这些分数被打高的人里去看看他们有哪些 commonbehavior pattern 让 AI 去做分析，然后我们再去人工检验一下。然后我们可以把他们初步作为我们的 benchmark 的一小部分，就是我们如果主观上觉得 make sense 就比如说 verification 的人，他们可能也 I don't know 就可能 attention 点可能更好说，就比如说他给了一些有针对性的修改建议，而不是单纯让他再做一遍。就是我们可以在每个高分维度找，先人工识别一些我们觉得确实 make sense 的行为模式。对然后把他们 benchmark 化对。所以我觉得这里现在我们 identify3类工作一类工作就是写 spec 本身一类工作就是把 spec 变成就是 input 跟，input 跟 desired output 还有三，就是我们需要有一个相对来说比较。

yih(00:08:57): 简单的框架来去跑这个 input 到我们 prompt 上看它的 output，然后比较着 output 比较 AI output 跟我们的 desire output。Yes 然后这里可能会有一些我刚才说的这种 research 性质的工作，就是它并不直接是奔刷本身，但它我们为了搞更需要研究一下我们的维度分数 correlate 为怎样的行为模式，我觉得每个能力维度，我们 info 至少搞出来两个行为模式吧。

yih(00:09:39): 我觉得我可以试试，就是两正两负就是两个好两个坏。

yih(00:09:44): 对，但是如果没有的话咱们就没有，但我们就有多个的话，我们可以优先就搞两正两副。对他们可能有一些 overlap 我觉得也没 sense 对好。

yih(00:10:06): 我觉得这就是前期的 benchmark 的部分，然后这里可能安娜的工作就确认一下简维度可能代码上要做什么修改好，这是这部分。这部分工作量也并不小。从这儿看到 language model 生成 jason L 的地步，然后从 jason L 后续的工作，我们是有。因为我们校校正这个计算要本身生成的没啥问题，好像目前也没出过问题就两种生成的东西，从来没出现过什么格式问题，或者是。OK 内容问题就是靠奔驰 mark 解决！然后。缺比如说格式符合，但是它缺一些内容，这种情况有，比如说这个分儿没打它空在那儿。

yih(00:11:11): OK 行，我觉得这些问题，先不管它，对你刚才解释一下，你刚才说客户管理是怎么做的，你说你做的 still 怎么样？

anna(00:11:26): Yeah 对。对是。

yihan-说话人04(00:11:39): 要用哪个数选择，然后就选择或者我以前都。

anna(00:11:46): 然后他就会自动进去。

yihan-说话人04(00:11:48): 我现在是已经把课录的过程给加到我们是。

anna(00:11:55): 生成报告的这个环节就是作为最后一个环节，我一开始在执行脚本的时候指定了客户的标准，那么他就按照这个标准来。我们就是不进行客服，需要人手工作。

yih(00:12:11): 确认一下 curve 的原始数据是从哪里？

anna(00:12:17): 原始是。

yih(00:12:21): 不，它需要放在哪，需要填在什么地方吗？比如说，当你说自动客服的时候，它从哪里读取客服的标准？

yih(00:12:33): 对 database。

yih(00:12:36): 也对客户来说，他想修改，其实挺麻烦的。

anna(00:12:59): 上周的话，我是加了一个标准，相当于是在这里你可以上传一个就是 by event 上传一个客户标准。

yih(00:13:10): OK 这个对格式有什么要求？

anna(00:13:13): 是我们的 csd 的？

simon(00:13:18): 沿用过去 SD 是吗？

yih(00:13:22): 我觉得这样好像感觉这个格式化是没有被强制住，就是万一将来比如说搞错了，他就还是会错了。

simon(00:13:29): 如果加了新题目的，肯定就要重新做它的 curve 的格式。

yihan-说话人04(00:13:35): 对现在的教练其实没有特别，他只要是个这样子的有了。

yih(00:13:42): 就是我觉得数据这一块我们要对 schema 严格一些，就是都要定义 schema 就是不能有，我们凭感觉不凭 convention 的，我觉得都不好，因为这样，现在其实现在不出错，等我们忘了，等我们再过两三周，我们又忘记了，他就会出错了。其实现在不会出错，这就是这些 schema 要清楚他们要 schema 要记在某个地方。

yihan-说话人04(00:14:08): 有一个是 ability，然后还有一个。

anna(00:14:15): 包括对。

yih(00:14:16): 飞马就好像。

anna(00:14:18): 因为是我这边，比如说。

anna(00:14:43): 但是我们现在看的，它就是一个 operating summer school 现在字段的话，我们是固定的，所以我这个这一块还是有再有校验一下的，因为我们那个什么什么 id，这些维度的话，因为它没有固定，所以就是没有校验。

yih(00:15:09): 那你说哪个部分没有专业？

anna(00:15:11): 后边就比如像对是屏幕的 id。

yih(00:15:18): 我觉得他们得校验，我可以做音部的进来，就比如说我们对最好不要有任何不校验的部分，就是对他要解决这些校验的问题。因为因为它本身没有任何机床的复杂度嘛，它。

anna(00:15:33): 对 so。

yih(00:15:33): 把数据做一些很简单的操作，所以这里的唯一的复杂度就在于我们确保它们正确的。

anna(00:15:40): 这个是可以校验。

yih(00:15:43): 我们先你看这里的所有的 process 就是首先客户是怎么被算出来的，我们先把这个事情就是客户是怎么来的？

simon(00:15:52): 以前是我让台湾 answer 我让 clothes。

yih(00:15:58): OK 然后。

simon(00:15:58): 我给他一个自然语言的描述，给他一份分数的 csd 可能出一个。

yih(00:16:09): 就这幅就需要授权教育？

yih(00:16:12): 这步可以这么做，但是我们需要个校验就确保，就比如说你有 cs 你你 input 就是个 csmd？

yih(00:16:18): 分数 csd 你拿出的是一个 curve 的？

simon(00:16:21): 对。

yih(00:16:22): 反正我觉得模块儿要不要因为因为 jfcc 不太好，因为有编码，我觉得就是你只能验证字段名字写谁，你验证不了别的人。

yih(00:16:37): 你比如说，如果你是个减少 object，你是不是可以验证东西？

anna(00:16:41): 现在也可以转？

yih(00:16:43): 没事，我们先定一下这里的有哪些流程，然后我们说每一步怎么验证 OK 首首先这有个 curve 的 generation。它的 input 是大一点。那我们的整个 sourceof input 是？

yih(00:17:10): 首先我们最后蓝皮书又给了我们一份结算 L 的分分数？

anna(00:17:17): 对。

yih(00:17:17): 我说最后两两种 model 都在生成的，不是一份。

anna(00:17:20): 对。

yih(00:17:21): 对某一个阶层。结算报告的分结算分数，我们要用这个参数，首先生成一个 curve？

yih(00:17:34): Cover 就从分数来的，就从一堆分数来的。反正从某一堆分数来，我们要选一些分数，选一些。我们选一些概念。

yih(00:17:58): 选一些。变成一组分数，你它有可能是一个 event，有可能是我们 merge2个 event 搞一个大块都有可能，反正有没有一组分数，然后我们把这组分数咱们这他。目前它会以结构一堆街上存在，还是一个街上 L 存在，就目前这里生成就单个街上吗？

yihan-说话人04(00:18:32): 比如说原始的。

yihan-说话人04(00:18:35): 但是 jason 它就是一个我们报告也是一个 JSON，然后那个分数就是嵌在每个。维度下面的这样子，分数的话，我是跑一个脚本，然后把某一这一组的分数给它。

yih(00:18:51): OK 咱们主要生成的是一个完整的报告阶层，我们还要提取这个分数阶层。

yihan-说话人04(00:18:54): 我们还要提取这个分数。

yih(00:19:10): 那这里会出？是这样吧？

yihan-说话人04(00:19:19): 他其实问你叫 jason 分数。

yihan-说话人04(00:19:24): 对是。

yih(00:19:25): 你说这里吗？

yihan-说话人04(00:19:26): 对，然后从。

yih(00:19:28): 我们要减少函数，我觉得减少函数更明确的，我们去校验它每个字段都。

yihan-说话人04(00:19:33): 对。

yih(00:19:33): 不对，就他 schema 比较就明明确他的 schema 我觉得。中间如果需要处理，直接放分数，校验完之后，我思考一下校验问题。因为我的直觉是 jason 的校验比 csc 更严格，更方便一些。csc 只能，而且 csc 是扁平的嘛 csc 没有那个没有层级。

yihan-说话人04(00:20:11): 我们现在的 CSV，它的每一列的命名的话，它是按照。

yih(00:20:19): 对他不。

yihan-说话人04(00:20:19): 他的痕迹也叉，这样他就是隐隐带一个痕迹。

yih(00:20:23): 对，但是你实际验证的时候，你不是按照一个严格的你还是把那些列全部每一个单独验证一遍？

yihan-说话人04(00:20:30): 不是按照可以加上严格一些的颜值。

yih(00:20:30): 不是按照某？因为这里这个 scheme 本身可能会根据题目不同而不同的。

yihan-说话人04(00:20:38): 是的。

yih(00:20:39): 你你需要有个 input这个 scheme 是什么？

yih(00:20:43): 我们还需要一个东西，这个东西是。我们其实现在这个地方是不知道他的，我们需要一个。

yihan-说话人04(00:20:58): 我们需要一个。

yih(00:21:01): 我们需要一个 event scheme。这里可能还有一些别的就是到后面就比如说有两题疑问，他们的题目的总体是不一样的，但他们有一道题是一样的，我们要那道题的，我们拿那道题抽出来做客，这完全有可能的事情。比如说我们的 event one 用了 thinking trap 跟 meeting verify event two 用了 thinking trap 跟 prompt optimization。

anna(00:21:33): 那只有两套 could？

yih(00:21:35): 不我想说他们的 think check 是 share 的 think check 其实可以出一套 top 出来的。我们现在的系统还没有 composability。如果你能在这里有 scheme 的话，其实你可以把这道题抽出来。因为你可以从这里把那道题抽出来，然后从另外一个里边的那把那道题抽出来，那这里可能。eventschema，这里可能存在。这里选两个东西，一个是选人。Event2可能存在选题的问题。

simon(00:22:22): 请再选 event。

yih(00:22:24): 不是你要我要。

simon(00:22:26): 两个礼拜。

yih(00:22:27): 就比如说首先我要确定我是要算哪个 event 的 cur，然后我可能要决定一下，我是要选一些题目。

yih(00:22:37): 你这里要 feed 的这个，那我们要的不是疑问词 feed 嘛，我们要的是。题目的 scheme，那这样的话我们可以在。

anna(00:22:50): OK。

yih(00:22:51): 可以在位置 feed1下 problemsheet 吗？

yih(00:23:01): 对。

simon(00:23:01): Scores 就整个 problem 的 scores 可以。

yih(00:23:05): 要跟被跟它连在一起，这样的话，这个地方就不用关心 eventschema 因为按理来说，event schema 就是个题目 schema 组成的，不存在题目一样。event 还有什么别的 meta data 在打分层面上。有没有可能出现题目虽然完全一样。

yihan-说话人04(00:23:27): 中英文模板。

yih(00:23:31): 好，那我们在这里费了一些。Event specific matter matter matter。

yihan-说话人04(00:23:38): 他的 proven id 其实是不一样。

yih(00:23:41): OK 那还是 problemspecific 那还好，那你还有没有什么 event 我没列，这可能没有用，我们把它列了，就包括我的存在。event specific 的 metadata 他们也可能以 schema 的前面存在，可能会影响 schema 会导致 schema 有一个区别。

yihan-说话人04(00:23:59): 对。

yih(00:23:59): 那到这个位置的时候用，就因为确定了，因为这用都在这里确定了进来。在这个位置 schema 就已经确定了。拿这球可以算一个 curve 出来。

yih(00:24:21): 那其实这个 curve 可以 apply 在任何的 type 上不一定非得 apply 在原始算它的，因为它也是我们用用这个 curve 去 apply。另外一个不是作为原始输入的 test。

yihan-说话人04(00:24:34): 个人不一样。

yih(00:24:35): 比如说我现在又让人做了一个同样的 problem。就我按理来说，我这个 code 是没有必要跟这个 input 绑定的，只要他们的 game match 就可以。

yih(00:24:47): 这个 curve 黑马是继承的？继承了。记成好，然后我现在有另外一组。

simon(00:25:07): Report 这。

yih(00:25:08): 我们有另外一组 languagemodel 生成的 report system。然后生成的 jason 分数？

simon(00:25:23): 我们实际操作的时候是直接用 curve 去改 reportjason 上面的就 report jason 它会现在这样 report jason 会自己带一个 later grade？

yihan-说话人04(00:25:37): 不认识？

simon(00:25:38): 是按。分三条零点八零点六。

yihan-说话人04(00:25:44): 对。

simon(00:25:44): 0.4的 percentile 算的，然后我们算完 curve 之后，retroactive 里把一开始的。默认的 personal letter great 改成 natural curve letter great 你听懂了吗？

yih(00:25:56): 我听懂，我建议不要改，我们不要有任何的 in place 的修改，我们都分成新的。不但你改了你就不知道你改没改？就是我想要明确的知道我们是改了还是没改，就是他改了就是个新的东西，就我们有原始的东西就是没改过的，就是改过的。

yihan-说话人04(00:26:20): 看吧，在那个客户范围内，那他就是没有改变，你要怎么判断他。

yih(00:26:24): 我们要判断这整个阶段有没有被处理过，有没有 process 过，就比如我怎么知道这个东西有没有被 apply 过某个 curve。

simon(00:26:32): 我们能不能再？

yih(00:26:33): 对我们得有一个新的阶层，它有变量，就或者说这个阶层有个变量，它被哪份客户处理过了。

yih(00:26:42): 它可以是 now，没有被任何客户处理过。

yih(00:26:46): 我就是他维持他那个什么0.8的默认克数是 OK 的。

yihan-说话人04(00:26:49): 上记录。

yih(00:26:52): 是的，否则我们现在先看一份 report，我怎么知道他被客户过没有，他被哪份客户过了？这里加一个。

simon(00:27:03): 然后就是 ontop of that 我们是不是最开始没有 care 过的 report jason 就不要按什么 percent 算你的 abcd 就直接给他 let's go 全部填一个，比如说 X 或者。

yih(00:27:17): 不在。

simon(00:27:18): 对。

yih(00:27:18): 这样更清楚一点。

simon(00:27:19): 跟是一起做的？

yih(00:27:22): 对然后。

yih(00:27:36): 所有的。其实我觉得我们这样是因为我们省的事就是我们按理来说是有两个 steamer1个 steamer，客户前一个 steamer 客户。

yih(00:27:45): 我觉得那样会更清晰一点，要么就那样，我不要这样做，我觉得我们重新设计一下。

yihan-说话人04(00:27:51): 我们只要有一个分数，我们 school 是固定的，那你客户跟？

yih(00:27:59): 因为这里 datapipeline 上我们要清洗，这里又没有什么复杂度，我们就是有一个 schema。Non curve 的 schema 它里面就是没有，然后这就很明显没有肯定没测过。我们也不用判断了。然后那我们就 OK 那我们这里加一个。

yihan-说话人04(00:28:15): 要记录一下是用哪一版？

yih(00:28:18): 那就是被客户过的才需要记录，没有被客户过就不需要记录，那这里还要加这里的我们就不需要这个所有可能默认都是 F 这种选项我们在这里加一步。

yih(00:28:32): 我想一想，OK 我们是说的是 report 接上是没？

yihan-说话人04(00:28:40): 没有不。

yih(00:28:43): 无论和位置，然后报结算生成的结单分数没有问题，反正提取分数跟你们来的位置是没有关系的？我们会更多是说我这个电话，这个 report 的 json 要根据这个 curve。他是先把分数提取出来，然后这个分数跟这个 curve 生成一组。他们三个人在一起生成一个 curve 的 report？

yihan-说话人04(00:29:20): 对。

yih(00:29:25): 或者说我们生成一个 curve 的 score 也可以，或者说我们先不管它，就是默认的 report 接上就是没有 letter，然后他们俩在一起就可以生成一个 curve 的。

simon(00:29:37): 对 report。

yih(00:29:38): 有 curve 的分数，他们俩在一起还没有 report，因为他是单独提出来的分数。

simon(00:29:41): 单独去考个分数 current letter grade。

yih(00:29:44): 就跟 for 是对应的 curve the letter。

simon(00:29:49): 然后 curveletter 加 report jason？

yih(00:29:51): 对只要他们俩在一起。再变成 herb 的 report，所以这样比较清楚。

simon(00:29:59): Ok. 

yih(00:30:00): 对。

anna(00:30:06): 好的。

yih(00:30:07): 那么这里我们的 curreport 就比较清晰，它会包含了它是被哪个 only curve 的。它因为这里的 schema 都是确定的。我们也完全知道这个 cur report 里的每个字段都是什么。别管是 event 带来的字段还是问题带来的字段应该都在这里了，因为他们在。

yih(00:30:30): 不知道。

simon(00:30:31): 对。

yih(00:30:33): 在这里处理，在它跟它交叉之前，我们需要知道这次 report 中的一个 curve 其实本来包含了两种 scheme，1个是 problemscheme，1个是 potential 的一些，那我们先不管这 potential 别的一个 curve 包含了一些 problem scheme 我们要先确保这个 report 接上它得是一个。

yih(00:30:58): 我们可以有两种做法，在实际过程中可能会分两种情况，一种情况是，比如说这个客户里，它包含了好几个问题的客户。

yih(00:31:10): 其中一道题在这个报告里我们就想用里边给他去做客，就是这个里边有三道题。

yih(00:31:15): 这三道题有一道题出现在这次 report 正式 event 中。我们就想用这道题里的去给他弄。

yih(00:31:23): 另外一种情况是这处也包含了五道题，这五道题中有三道题就是这次 report 也就只有三道题，这三道题都是就是 subset out time？

yih(00:31:33): 或者是他们俩有一个 overlap，就他们俩 intersection 里面有东西，就我觉得一个比较我不确定那样是不是太复杂。

yih(00:31:45): 你就把他们的 intersection流量容易出问题，还是不要我觉得。我觉得让他是他的 subset。因为这边你可以提取嘛，这边你可以再切分出来，比如说我就那一道题的这边去切分是比较容易的。因为你上生成完成 report，比如说我先看你的客户现在是分体的？但我还有总分的客户。

simon(00:32:18): 有一个 overallmean，还有它的 ability 的 summary 的每个能力分，它也是。

yih(00:32:25): 这个错误也可能包含了总分的客户。

simon(00:32:29): 他一定。

yih(00:32:30): 不说他有些共性。

simon(00:32:37): 总分能力分和问题客观分！

yih(00:32:43): 我这边给你扣。对很多小孩要更负担大是。

yih(00:32:53): 他非要好好做对，否则他能出错的地方太多了。你先简化一点，你你根就没有意义了。

simon(00:33:22): 能力分离的一段时间没有？

yih(00:33:27): 我能力问题那几个题目还在就一。就比如说这个能力，它只跟这两个问题有关，如果你把第三个东西去掉了这个能力自然是有意义。说我们现在能力是在所有产品不是。

simon(00:33:48): 那你你再说一遍。

yih(00:33:50): 比如说我们的 verification 维，我们有五道题，因为有个 verification 维，我们是不是在所有情况都凭 verification 还是就只要它凭 verification 维度的题目还在这里就所以说它是有个 dependency 的微信那个东西。他在哪，他在我们有 dimension 编码的正确的东西在这定义这个 dimension 它得看到，那我自己问的哪些？这是个很重要的 impressive 的信息，我现在有没有被 record 在我们的 system 里？

simon(00:34:26): 哪个。

yih(00:34:27): 这个 dimension 在这次 event 中，它具体是跟哪几个 problem 是打分相关的。

simon(00:34:34): 没有对。

yih(00:34:34): 好那。

simon(00:34:35): 那是只在你只能通过 get help 安娜改的代码版本来看是什么什么个情况。

yih(00:34:44): 这个事情他被严格去盯管。对。本来是我。Depend on. 

yih(00:35:07): What trouble. 这是一个单独的 CPM 的去。他是能被校验的就是他应该跟 prompt 是扣，就是他是跟 prompt 是一致的，对他不能说这个跟我写的是一样，然后 prompt 其实多引用一个 problem 和少引用一个 problem。这可能是要在前期就要做校验。然后他应该被涉及到后后期这边来，这样才能去决定这边怎么去选这个东西的时候，他还选取是否是有意义的。对有没有意义，我们刚才说这个信息上面记录下来，它不应该被 implicit 就好像丢掉这个信息是很重要的。没事，他去他们在录。非常重要！

yih(00:36:16): 那我们先 OK，我们先把它放出来，这个系统我们先记录一下怎么用，我们可以再说，那这里的选取我稍微的再确认一下，因为我们这里这客户包含了总包含了一个 ability 的总分包含了每个维度的 ability，对再这边就是不包含什么的客户。

simon(00:36:35): 总分倾向能力分四个客观分。

yih(00:36:42): 总分就是气象能力分的平均数跟。

simon(00:36:46): 各个客观分子平均数。

yih(00:36:47): 的 geometric，但当！你刚说的是可以事后再被 compute 的他好像放在 curve 里。活动化点，它跟他们放在一起，稍微有一点不太一样，因为他们都是原始分，那总分这个被算出来的分分。

simon(00:37:15): 我不太确定你说的 distinction 有什么意义，因为那些能力翻译都是它也不是原始的能力翻译是。

yih(00:37:24): 每个问题下有个努力。

simon(00:37:26): 话题的人选择评估一下。那也不是最原始的分数。

yih(00:37:33): 那他们多少最原始的分数？

simon(00:37:35): Proposal 是这样。

yih(00:37:38): 我思考一下这两者之间有没有什么在处理上有没有什么我们需要注意的区别，最原始分数最好处理，因为他们不会再变了，他们也不得开这种东西，他们就只看到那题目而已，所以我算出来的分数在一米中得看到，就我们选取的时候，他算的这个题目？

yih(00:37:58): 我们可以先不说想一想。

simon(00:38:15): 我在这里什么问题，就是只要我们需要保留它是从哪一些东西当中算出来这个信息，然后确保它算是正确的。这样它确保之后就是就 OK 了。

yih(00:38:31): 总分的话只要有语文台 ID 就可以了，有那次的机器。我们可以根据 eventid 去 retrieve 内测所有的。

yih(00:38:48): OK 我们回头我们再给大家几个问题是这个 curve apply to1个 report 的时候会发生什么？这里我们问之所以这有问题是因为他们的阶段可能不完全 match，因为我们可能要用一次 event 的客 curve 给另外一次的客 curveevent 去 apply。在这个情况下，总分的块我们几乎总是要重新断？

yih(00:39:25): 不存在总分也不一定它可以，就如果两次题目完全一样，它可以用别人总分可能可以。尤其也非常有可能，就比如说我们把同一个东西分两次技术做我们用一个种子来去 apply both 这个疑问。我觉得我们可以确认，如果他们 schema 完全 match，这肯定是可以的，就他们的题目完全一样。两维度也完全一样，先我们先不管维度可能发生的变化，他们的题目完全一样。

simon(00:40:05): 还要打分 prompt？

yih(00:40:11): 两个 version 什么？

simon(00:40:13): 对。

yih(00:40:14): 我这样记录下来。

yih(00:40:25): 我们怎么用再说打分 prompt 的 version 我们把它放在。

simon(00:40:32): lm 到 reportjason 这一步。

simon(00:40:38): 他至少是记录在。

yih(00:40:39): Properly. 

simon(00:40:41): 现在没有在 reportjason 里。

yih(00:40:43): 我们把它记录进去？

simon(00:40:45): 对。

simon(00:40:47): 然后现在？现在 prosperation 它没有一个命名的方法，它就是在 get 里面，就你只能通过它是几月几日的。

yih(00:41:08): 没事，我给每每个 com 都有至少有个 commit 的。

simon(00:41:11): 他有对没，他有这样，每次 from 更新会有一个 commit。他会就我会提一个 PR？

simon(00:41:22): 然后他就会合进来。

yih(00:41:23): 那你一定要存在一个是存在唯一的 identifier。

yih(00:41:29): 我们这个东西要加一个。

simon(00:41:35): That report, Jason. 

yih(00:41:39): 对。关窗这个 uid，有你改给你发。我们就暂时用。我们就不会再问什么新东西了，这样子的。反正有个肯定是可以找到对，然后我们先把这个任务先留着就是这里的合并，它是需要满足某种 condition 才能带过去。这 condition 是什么？还有点复杂？

yih(00:42:19): 他按理来说，最好是他们中的打分窗口最好完全一致。就另一种情况，如果他们什么都问题一致打分窗口问题一致，期末完全一致，那就一定是可以合的。

yih(00:42:30): 一定可以。

yih(00:42:32): 存我们可以先就做版本，我们先不做更复杂的版本，比如说这两边题目不完全一致？

yih(00:42:41): 因为这可能可以，我们可以将来再去 extend 这个 function 对我们现在就。就确保他们什么都一样，但什么都一样，我们指的是能力维度跟。能力维度跟。

yih(00:43:02): 对。

simon(00:43:02): 屏幕。屏幕 id。

yih(00:43:06): 对。PID 还有。

yih(00:43:12): 晚上。

anna(00:43:15): 这次创的 version 用发新的话，他如果说一个里面改好几个。

yih(00:43:24): 每个 prompt 只会对应一个 action，就是你要给每个 prompt 都有一个 version 的位置，就每道题的。

yih(00:43:34): 说，我们这里一共有多少个 prompt，一共有？

simon(00:43:40): 我们要这样做吗？为什么不整一个 pro 作为？

yih(00:43:45): 你在整一个 prom，你只是整一套，因为你可能只改一部分没有改善的部分。

yih(00:43:54): 就不是你可能改了题目 A 的 prompt 没有改题目 B 的 prompt 题目 prompt 按理来说是可以用 OK。

simon(00:44:04): 你来说这里面有几个 problem 嘛？

yih(00:44:08): 等一下，我在咱们今天可能确实可以，但是可以。因为如果一个 prompt 没有动，它就不会出现在那四次 commit hash 里，就只有 prompt 会动的时候才会出现在那四次 commit hash 里。你总是知道 latest 的每个 prompt 的 latest 就是每个 prompt 出现最后出现的 key tag 就是它的版本。或者说 prompt 当时运行的时候运行的是哪个 traininghash 里的 prompt 总是知道的。所以我们只需要记录。

yih(00:44:45): 运行时的，我们只需要记一个 contract 安娜，你刚才问题是什么来着？

anna(00:44:50): 也有可能改了好几个 problem 的。

yih(00:44:56): 这会当成什么问题？

anna(00:44:58): 他们就用相同的。

yih(00:45:03): 是，但是你看我们定想确保的是 merge 的时候。

yih(00:45:08): 他们用的是同一个..？

anna(00:45:10): 对。

yih(00:45:11): 按照你说的，从一开始可能只多个 prompt。我们会记录。假设，比如说这里 multiple 和 problem 被 theproblem 被 edit 了。

yih(00:45:28): 那他们就一定是 differenthash，那我就意味着我们最好意味着我们不能直接 apply 这次 curve。

anna(00:45:31): 那就意味着我们。

yih(00:45:36): 我们就要需要人工去看！

anna(00:45:38): 对，然后最后修改。

yih(00:45:41): 不，他记录的是，就是运行的时候，那次 commit 对最后修改最后的 prompt 修改最后一次，就因为运行，你可能还修改过其他的，就你的 commit，还有因为其他的事情发生改变，所以这次的 hash 是。任何 problem 发生改变，我们可以做的更细，就是某一个 problem 发生改变，那我们现在简单一点任何 problem。发生改变。那这样的话我们就可以基本就是本来我们可以做这种几圈，每一个 prompt 我们拆可以拆出我们能拆出什么 problem 的客观打分。

simon(00:46:23): 他现在的就已经拆的很细了，还有。首先你 ability summary 有一个，然后 problem summary1个 final summary 有一个，然后 expert review 有一个就是C 包有，这是已经是五个框架的这些框架是 apply 就是这些现在是 doliquid 文件它是 apply to 就是，然后像每每能力它会有一个每能力的 expert review 的，然后每一道题目它会有一个题目的客观分的打分的标准，它对它这些细则会跟 doliquid 到时候拼在一起。

simon(00:47:07): 一起喂给了？

yih(00:47:10): 我们最终的目标是把他们全部都给认出来，那我们现在先这样做。

yih(00:47:14): 最终应该每个 prompt 都可以单独对过，因为其实事情是那样的。

yih(00:47:19): 我们暂时为了简简易，我们先把未来要做的事情是把每一个他们都单独 version，我们暂时选择统一 version 所有的 prompt。这样的话我们至少可以做些基本的保障就是。这还是有可能错，我们先把它基本保障做了就有可能会出现。他告诉我们，这两次的创作不一样，但其实改变可能很小，你可能只改了一点点。

yih(00:47:57): 但是那个他就那我们那时候就手工 override 这个 case 就我们知道我们在做一些危险的事情。

simon(00:48:20): 我们现在这 jason 分数不就是于克，他也是用 jason。

yih(00:48:27): 全用介绍。

simon(00:48:28): 那我们 crop 就也是合在 repo 里。

yih(00:48:35): 什么意思？

simon(00:48:35): To 就。比方说跑完了一次 report 之后生成一个 curve 的 json 文件，那它存放在什么地方？

yih(00:48:49): OK OK。

yih(00:48:51): 在我们总是编程的时候在被破例，比如说安娜那边怎么在系统里具体的实现可以在。看怎么接过去？

yih(00:49:09): 然后这里我们只要把每个箭头上都校正都校验一下就好。比如说上次就有一部分分数没有被成功扣，不知道在哪个环节出问题了。

simon(00:49:24): 然后，然后。

yih(00:49:28): curve 到 curve 的什么？

simon(00:49:35): Letter grade. 

yih(00:49:36): 这一步为什么出问题了？

anna(00:49:39): the problem。

simon(00:49:41): Sv 的。

simon(00:49:43): 这样的原本。

yihan-说话人04(00:49:47): 中文和英文用的是同一套，然后因为中文和英文的 problem id 是他们是最后一位不一样零和一对，所以就去掉了前面的那个数字的那个。

simon(00:50:02): 你那要不就是 csb 的 code name 被改变了？被改变之后，程序没有读到他就直接默认就没有 curve，然后他之所以。

yih(00:50:13): 对。

simon(00:50:14): 还能让我们看你的绝对没有什么问题，就是你们这边。

simon(00:50:18): 已经一开始有一个 ABCD 了，我们会觉得没问题！

yih(00:50:24): And for the other point? 

anna(00:50:39): 那所以就还是我们要严格按照 problem INT 完整的 problem ID 来。

yih(00:50:47): 对是动态功能，这也跟规定一样。

yih(00:50:50): 他应该做变量为背景，而不是。

anna(00:50:54): 如果说是。

yihan-说话人04(00:50:55): 屏幕是完全一样，它只跟中文和英文，那它其实还是要保养。

anna(00:51:00): 现在两套？So so. 

simon(00:51:05): 我们现在的 practice 是用的。

anna(00:51:07): 要不要统一？

simon(00:51:08): 然后。

anna(00:51:09): 对。

yih(00:51:09): 我们可以在没事，我们可以在这个系统再去加一些 feature 我们暂时先要求他们都是一样的，比如说我们到时候可以在 verification 阶段，我们的 verification 可以写成自定义代码，比如说我们认为哪些东西其实可能是一样的。就比如我们可以重新定义一下什么叫 equality 就在 verification 中是可以做的。就我们有一个自定义的 equality 我们有一些特殊的 case 比如说，如果只是语言问题，他们我们可以在有些情况下 regardingas the same 我们需要某种 definition of就 compatible a curve 就是 has to be compatible with 这个理解。

yih(00:51:49): 我是什么跟什么样 comparable 的时候突然有点乱是。这个 reportjason 它会是一个计算分数要跟它是同态的不对。

yih(00:52:03): 从 curve 到 curvelet grade，它要从分数的。重新画一下，现在有点乱，这两天会跳不来这。

yih(00:52:28): C 的 letter grade 跟？跟 for chance，他们要一起的出。

simon(00:52:35): 他们要一起的出。

yih(00:52:37): 这个东西对这里不 compatible 问题，这里有个 compatible 问题，那它到底能不能混在一起？对这里的问题是。是同一个问题，他们只要一个满足，应另外一个英雄也满足？他们是肯定有问题，你觉得没道理，这里满足那里不满足吧？

yih(00:53:17): 就是我们现在要定义的是这个什么叫 compatible 就是刚刚我说可能不同语言是可以 compatible 的，就他们可以 regard 也可以，我们要定一个 customercompatibility 的函数来去决定他们俩什么时候能。

simon(00:53:37): 对。

yih(00:53:38): 现在简单的说法就是什么都一样，但是可能语言可以不一样，其实我写在这对，就这个东西。

anna(00:53:45): 小的 I。

yih(00:53:50): 他们 id 语言可能可以不一样。

anna(00:53:59): 我们现在屏幕的版本的收入 id 运营的 PPT。

yih(00:54:07): 对。

anna(00:54:07): 对。

yih(00:54:08): 大家至少都有数字，那个数字还是比较清深刻的，我不以汉语。

anna(00:54:14): 我不以汉语。

yih(00:54:20): 有吗，有吗。不有吧？

simon(00:54:25): 我等于。

anna(00:54:26): 对。

yih(00:54:27): 完全一样的数字题目不一样，我不该有这样的情况。

yih(00:54:32): 你现在看，除非它是那个题，就因为我们系统中没有删老题目，它有可能出现那个系统里还有那个老题目就是按理来说，所有的数字就只能代表一个题目。

simon(00:54:46): 那一道题目会被修改吗？

yih(00:54:49): 对。

anna(00:55:02): 倒数第二个的话就是他的房本。像的话，90349431就行。

simon(00:55:16): 就是倒数第二位是比较大的版本变化，然后就是同一道题目。有小改可能不改，六位代码直接就是小改。如果他改了之后变得比较大，像另外一道题就会变换倒数第二个。

yih(00:55:52): 还有什么问题，我们要实现用街坊那种什么 dota 之类的。就我们具体来说，我们要定义每一个位置的 scheme 然后我们要定义每个箭头什么情况下可以往前走，然后所有那种需要两个东西合成一个东西的，我们要去定义它什么时候能合并。

yih(00:56:18): 先说这么多，怎么做，我先看一看，安娜如果你来实现这个东西，你会怎么做？

anna(00:56:40): 的是他要不要加到自动化，就我在生前报告的自动化。这个 pose 的话肯定是要先来提前先标注定。

yih(00:57:02): 我怎么提前把标准变成提前到什么？

anna(00:57:05): 他肯定是要人工人为的进行操作才能。

yih(00:57:17): 你说这个位置？对这里肯定有一定的度！或者说我们随便用哪种统计方式来刻？我们可以有个默认的 cur 方法，就比如说我一直用的平均分以上一个标准差两分。

yih(00:57:43): 就他们都以配置文件的形式存在嘛，他们都就该是他们也都是有 schema 去定义这些东西，比如说有个 schema 去决定怎么选人。所以你可以想象那种，比如说什么那种 non non SQL 的 database 的那种选人方式。

anna(00:58:12): 二的话他。

anna(00:58:27): 它是作为 event 还是 create problem 这样子就是比如说我一道题，我就给它这样的一个空，那我之后就是有不同组合的 event 的话，那我就要拼一下这个。

yih(00:58:46): 总分就要重新搞？

yih(00:58:47): 总分的 code 但是我觉得 problem 的 code 确实可以独立成分。按理来说，将来 perdimension 也可以独立存在，因为虽然他们的打分的题目来源不一样，但是就我们的目标是做出一些稳定的 dimension 嘛，这 dimension 是 cross different type cross different test 他们都是稳定的，就他们原始分数是稳定的，是有意义的，现在还做不到，但是就是 eventually 这个即使不是一个 dimension 在从不同题目打出来，它也是如果我们的 prompt 写的足够好，它也是足够可比的。

yih(00:59:24): 虽然你是做 simple trap 我是做 meeting verification，但是我们比如说在比如说某维度上打分，都是仍然可以分出高下的，这是我们的目标，就现在我们哪些部分是被自动化的你能先指一指。

yih(00:59:54): 就你，你或者使用系统中是用到了哪几个哪几条？

anna(01:00:03): 这 report 是吗？对，然后因为因为我们目前他这个课文他是定的。

yih(01:00:12): 我不能否定。

anna(01:00:12): 他是现在上传到滴滴的话，然后他是。

yih(01:00:16): 按照我们先从这里开始，因为这边是生活的客户的一个程序，因为我们现在这种客户表现这个客户假设已经有了？

yihan-说话人04(01:00:22): 对。

yih(01:00:22): 这边我们是先从 language model 生成了一个？

yihan-说话人04(01:00:25): 不是没有，这是他是直接在乳房建设上。

yih(01:00:31): 是从这里到一个2report，就这里现在是有条线的对，就是从他加他到他是有条线的。

anna(01:00:42): 它可以手工也可以自动，然后自动其实还没有跑过，就是真实的。

yih(01:00:49): 你说总分的计算现在是什么情况？

anna(01:00:52): 走吧那。

yih(01:00:53): 现在自动的？

simon(01:00:55): 我们在早上计算。

yih(01:00:56): 因为那总分不就是那两种总分的就 microphone me 之前会出过一次问题，我就说。

anna(01:01:02): 但是。

yih(01:01:03): 之前就是他默认的 report 里没有对吗？我做分析出问题出错的那次就是因为。原始的 cc 里没有总分，所以它是新算出来的。

yihan-说话人04(01:01:14): 对。

yih(01:01:14): 好对。

yihan-说话人04(01:01:15): 因为我给报了 CSV 没有这一列。

yih(01:01:20): 可以有。

simon(01:01:21): 有报这项其实是有的。

yihan-说话人04(01:01:22): 对。

yih(01:01:23): OK 好的行。也现在有一条路线，那我们可以先做这条路线，先不管那条路线，先做这条路线，就先做，先把两个 report 的先把 report 接访跟 curve report 给分开。

yih(01:01:43): 然后把 curve 的 schema 定下来，把 curve 的 letter 的 schema 定下来，把这个接算分数这个东西单独做一个东西出来，然后把接算分数跟 curve 的 apply 的这个 script 弄好。然后对再把 curve letter 跟这个对把这些东西做了。

yih(01:02:06): 那部分第二部分？

yih(01:02:08): 因为现在我们总是可以获得一个客，我们可以再想办法校验，但我们总是可以拥有一个这个部分，然后这些部分都要改，就是 report 阶段上的最多要加一些东西。

simon(01:02:22): 对。

yih(01:02:23): 这单过去一不从这儿掉一。这是本身上面要加的东西。这是我们第一步要做的东西，下一步还是我们第二步做的。

simon(01:02:45): 30个 for 追才是我们加的。

yih(01:02:49): 推荐下单的。

simon(01:03:34): OK 那就开始做这次暑假！

anna(01:03:42): 依附三我们只要知道一就可以知道三有个地方记录的话。

yih(01:03:51): 什么来着，我又看。Of time. B 跟三没有什么必然联系吧？没有别的联系。

simon(01:04:06): 然后这个三是加在原始的方案不是报错。

yih(01:04:12): 在有客户之后，你他仍然他对他可以被干掉，他也可以不回。

simon(01:04:17): 最后一是就二跟三是在 on curve for this 就要有，然后一是点燃你 curve 之后再。

yih(01:04:26): 对我们吃饭。

simon(01:04:27): 那你在干嘛？

yih(01:04:32): 这些是。

yih(01:04:37): 这是客。加的位置之一。

yih(01:05:04): 那咱们这样安娜你你先回头我把这个东西给发你，你先整理个文档整理个大概的序把它变成文字，对，那我们一起再确认一下。然后再做对。